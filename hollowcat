<!DOCTYPE html>
<html lang="en-us">
<head>
  <base href="https://cdn.jsdelivr.net/gh/web-ports/hollow-knight@latest/">
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Cat-Nitro Unity Loading System</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <link rel="shortcut icon" href="TemplateData/favicon.ico">
  <style>
    :root{
      --bg:#000;
      --neon-pink:#ff00ff;
      --neon-green:#00ff9c;
      --dim:#0a0a0a;
      --txt:#e8e8e8;
      --muted:#7a7a7a;
      --grid:#0c0c0c;
      --bar-bg:#151515;
      --bar-glow:#26ffd5;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--txt);}
    body{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; overflow:hidden;}

    /* Layout shells */
    #stage{position:fixed; inset:0; display:grid; grid-template-columns:1fr min(1100px,92vw) 1fr; grid-template-rows:1fr; align-items:stretch;}
    .skid-col{position:relative; overflow:hidden; opacity:.5; filter:drop-shadow(0 0 6px rgba(255,0,255,.25));}
    .skid-stream{position:absolute; inset:0; padding:12px; line-height:1.15; font-size:12px; color:var(--neon-green); white-space:pre; user-select:none;}
    .skid-stream i{font-style:normal; color:var(--neon-pink);}
    .skid-fade{position:absolute; inset:0; background:linear-gradient(180deg, rgba(0,0,0,.9), transparent 30%, transparent 70%, rgba(0,0,0,.9)); pointer-events:none;}

    /* Center panel */
    #panel{position:relative; margin:auto; width:100%; height:100%; display:flex; align-items:center; justify-content:center;}
    #glass{position:relative; width:100%; height:min(85vh,780px); border:1px solid rgba(255,255,255,.08); background:
      radial-gradient(1200px 600px at 50% -10%, rgba(255,0,255,.08), transparent 60%),
      radial-gradient(800px 400px at 50% 120%, rgba(0,255,156,.08), transparent 60%),
      linear-gradient(0deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
      border-radius:16px; overflow:hidden;
      box-shadow: 0 0 0 1px rgba(255,0,255,.08) inset, 0 20px 60px rgba(0,0,0,.6);
    }
    .grid{
      position:absolute; inset:0; background:
        linear-gradient(transparent 23px, rgba(255,255,255,.04) 24px, transparent 24px),
        linear-gradient(90deg, transparent 23px, rgba(255,255,255,.04) 24px, transparent 24px);
      background-size:24px 24px;
      opacity:.18; pointer-events:none;
    }

    /* Boot overlay (3s) */
    #boot{
      position:absolute; inset:0; display:flex; flex-direction:column; padding:24px; gap:10px;
      background:rgba(0,0,0,.75);
      backdrop-filter: blur(2px);
    }
    #brandline{font-size:14px; color:var(--muted);}
    #title{font-size:20px; letter-spacing:.5px; color:var(--neon-pink); white-space:pre; text-shadow:0 0 10px rgba(255,0,255,.5);}
    #log{
      flex:1; overflow:hidden; border:1px solid rgba(255,255,255,.08); border-radius:8px; padding:12px;
      background:linear-gradient(180deg, rgba(255,0,255,.05), rgba(0,255,156,.05));
      font-size:13px; color:#b8ffef;
    }
    .logline{opacity:.0; transform:translateY(6px); transition:opacity .2s ease, transform .2s ease;}
    .logline.on{opacity:1; transform:none;}
    .cursor{display:inline-block; width:9px; background:var(--neon-green); margin-left:2px; animation:blink 1s steps(1,end) infinite;}
    @keyframes blink{50%{opacity:0;}}

    /* Loader UI */
    #loader{
      position:absolute; inset:0; display:flex; flex-direction:column; padding:24px; gap:18px;
      opacity:0; pointer-events:none; transition:opacity .35s ease;
    }
    #loader.active{opacity:1; pointer-events:none;}
    #loader .head{display:flex; align-items:center; gap:10px;}
    .dot{width:8px; height:8px; border-radius:50%; background:var(--neon-green); box-shadow:0 0 12px var(--neon-green);}
    .head h1{margin:0; font-size:18px; color:var(--neon-green); letter-spacing:.4px;}
    .sub{font-size:12px; color:#8affda;}

    /* apt-style progress */
    #apt{
      font-size:16px; color:#d8ffd2; display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      text-shadow: 0 0 8px rgba(38,255,213,.3);
    }
    #apt .label{color:var(--neon-pink);}
    #apt .bar{font-weight:700; letter-spacing:1px; min-width:240px;}
    #apt .pct{min-width:64px; text-align:right;}
    #meta{font-size:12px; color:#9fffe4;}

    /* Unity canvas container â€“ hidden until ready */
    #unity-container{position:fixed; inset:0; display:none;}
    #unity-canvas{display:block; width:100%; height:100%; background:#000;}

    /* Mobile warning (hidden by default) */
    #unity-mobile-warning{
      display:none;
      position:fixed;
      inset:0;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.8);
      color:#fff;
      font:14px ui-monospace, monospace;
      text-align:center;
      padding:20px;
      z-index:999999;
    }

    /* Small sizing */
    @media (max-width:900px){
      .skid-col{display:none;}
      #glass{height:78vh;}
      #apt .bar{min-width:180px;}
    }
  </style>
</head>
<body>
  <div id="stage">
    <div class="skid-col">
      <div class="skid-stream" id="skidL"></div>
      <div class="skid-fade"></div>
    </div>

    <div id="panel">
      <div id="glass">
        <div class="grid"></div>

        <!-- 3s boot overlay -->
        <div id="boot">
          <div id="brandline">[init] Cat-Nitro loader environment</div>
          <div id="title"></div>
          <div id="log"></div>
        </div>

        <!-- Main loader -->
        <div id="loader">
          <div class="head">
            <h1>Loading: Hollow Knight</h1>
          </div>

          <div id="apt">
            <span class="label">Standby..</span>
            <span>unity-runtime</span>
            <span class="bar" id="aptBar">[--------------------]</span>
            <span class="pct" id="aptPct">0%</span>
          </div>

          <div id="meta">
            <span id="mbText">0.00 MB / 0.00 MB</span>
            <span id="phaseText" style="margin-left:14px; color:#b3ffef;">preparing</span>
          </div>
        </div>
      </div>
    </div>

    <div class="skid-col">
      <div class="skid-stream" id="skidR"></div>
      <div class="skid-fade"></div>
    </div>
  </div>

  <!-- Unity mount -->
  <div id="unity-container">
    <canvas id="unity-canvas"></canvas>
    <div id="unity-mobile-warning">
      WebGL builds are not supported on mobile devices.
    </div>
  </div>

<script>
(function(){
  /* ---------- Side "skid" code generators (lightweight) ---------- */
  function randHex(n){var s="";for(var i=0;i<n;i++){s+=("0123456789ABCDEF")[Math.floor(Math.random()*16)];}return s;}
  function makeSkidLine(){return randHex(8)+""  +randHex(4)+"  "+randHex(8)+"  "+randHex(2)+":"+randHex(2)+":"+randHex(2);}
  function startSkid(el){
    var lines = [];
    function tick(){
      lines.push(makeSkidLine());
      if(lines.length>80) lines.shift();
      el.textContent = lines.join("\n");
    }
    tick();
    return setInterval(tick, 70);
  }
  var skidTimers = [];
  skidTimers.push(startSkid(document.getElementById("skidL")));
  skidTimers.push(startSkid(document.getElementById("skidR")));

  /* ---------- 3s boot overlay with typed title + logs ---------- */
  var boot = document.getElementById("boot");
  var title = document.getElementById("title");
  var log = document.getElementById("log");

  var titleText = "Cat-Nitro Unity Loading System";
  var ti = 0;
  var typeT = setInterval(function(){
    title.textContent = titleText.slice(0, ++ti);
    if(ti >= titleText.length){ clearInterval(typeT); title.insertAdjacentHTML("beforeend", '<span class="cursor"></span>');}
  }, 35);

  var bootLines = [
    "[0.001] kernel: entropy pool initialized",
    "[0.023] net: link up on lo, eth0",
    "[0.071] fs: mounted /cn-runtime read-only",
    "[0.119] cn-init: probing WebAssembly target",
    "[0.183] cn-init: enabling fetch streams",
    "[0.244] cn-init: preheating shader cache",
    "[0.317] cn-init: ok"
  ];
  var li = 0;
  function addBootLine(){
    var d = document.createElement("div");
    d.className = "logline";
    d.textContent = bootLines[li++];
    log.appendChild(d);
    requestAnimationFrame(function(){ d.classList.add("on"); });
    if(li < bootLines.length) setTimeout(addBootLine, 180);
  }
  addBootLine();

  /* ---------- Loader UI state ---------- */
  var loader = document.getElementById("loader");
  var aptBar = document.getElementById("aptBar");
  var aptPct = document.getElementById("aptPct");
  var mbText = document.getElementById("mbText");
  var phaseText = document.getElementById("phaseText");

  function asciiBar(p){
    var slots = 20;
    var filled = Math.max(0, Math.min(slots, Math.round(p*slots)));
    return "[" + "#".repeat(filled) + "-".repeat(slots - filled) + "]";
  }

  /* ---------- Network progress model (updated) ---------- */
  // We keep a dynamic total estimate that can grow as we learn true sizes.
  var estBytes = 0;           // current best estimate of total bytes
  var loadedBytes = 0;        // bytes actually read so far
  var unityProgress = 0;      // 0..1 from Unity loader
  var knownSizes = Object.create(null);  // per-URL size we think we know (HEAD or GET)
  var fallbackTotalMB = 860.36;          // only used if we have no sizes at all

  function fmtMB(b){ return (b / (1024*1024)).toFixed(2); }

  async function getSize(url){
    try{
      var res = await fetch(url, { method:"HEAD" });
      var h = parseInt(res.headers.get("Content-Length")||"0", 10) || 0;
      return h;
    }catch{return 0;}
  }

  // Fetch a part while tracking progress; also learn/adjust true size from GET headers.
  async function fetchWithProgress(url){
    var response = await fetch(url);
    var getLen = parseInt(response.headers.get("Content-Length")||"0", 10) || 0;

    // If our HEAD guess was missing or wrong, adjust the estimate now.
    var prevKnown = knownSizes[url] || 0;
    if(getLen > 0){
      if(prevKnown === 0){
        estBytes += getLen;
        knownSizes[url] = getLen;
      }else if(getLen !== prevKnown){
        estBytes += (getLen - prevKnown);
        knownSizes[url] = getLen;
      }
      updateUI(); // reflect the better estimate immediately
    }

    var reader = response.body.getReader();
    var chunks = [];
    var received = 0;

    for(;;){
      var rr = await reader.read();
      if(rr.done) break;
      var value = rr.value;
      received += value.length;
      loadedBytes += value.length;

      // If for any reason we pass our estimate, bump the estimate up to match reality.
      if(loadedBytes > estBytes){
        estBytes = loadedBytes;
      }                     
      updateUI();

      chunks.push(value);
    }

    var fullBuffer = new Uint8Array(received);
    var offset = 0;
    for(var i=0;i<chunks.length;i++){ var chunk=chunks[i]; fullBuffer.set(chunk, offset); offset += chunk.length; }
    return fullBuffer.buffer;
  }

  async function mergeFiles(fileParts){
    var buffers = await Promise.all(fileParts.map(function(p){ return fetchWithProgress(p); }));
    var mergedBlob = new Blob(buffers);
    return URL.createObjectURL(mergedBlob);
  }

  function getParts(file, start, end){
    var parts = [];
    for(var i=start;i<=end;i++){ parts.push(file + ".part" + i); }
    return parts;
  }

  /* ---------- UI updater (updated) ---------- */
  function updateUI(){
    var dynamicTotal = estBytes > 0 ? estBytes : (fallbackTotalMB * 1024 * 1024);
    if(loadedBytes > dynamicTotal){
      dynamicTotal = loadedBytes; // never let the "total" be smaller than "done"
    }

    var netPct = dynamicTotal > 0 ? (loadedBytes / dynamicTotal) : 0;
    var enginePct = (unityProgress||0) * 0.9; // reserve a slice for engine init
    var overall = Math.max(netPct, enginePct);

    // Clamp to [0,1] for display so we never show > 100%
    var clamped = Math.max(0, Math.min(1, overall));

    aptBar.textContent = asciiBar(clamped);
    aptPct.textContent = Math.round(clamped*100) + "%";
    mbText.textContent = fmtMB(loadedBytes) + " MB / " + fmtMB(dynamicTotal) + " MB";
  }

  /* ---------- Kick everything off after 3 seconds of "boot" ---------- */
  var started = false;
  setTimeout(function(){
    if(started) return;
    started = true;
    boot.style.display = "none";
    loader.classList.add("active");
    startUnityFlow();
  }, 3000);

  /* ---------- Unity flow ---------- */
  async function startUnityFlow(){
    phaseText.textContent = "fetching assets";

    var dataParts = getParts("Build/hk.data", 1, 42);
    var wasmParts = getParts("Build/hk.wasm", 1, 2);
    var allParts = dataParts.concat(wasmParts);

    // Try HEAD first to seed the estimate, but don't trust it blindly.
    var sizes = await Promise.all(allParts.map(getSize));
    estBytes = 0;
    for(var i=0;i<allParts.length;i++){
      var sz = sizes[i]||0;
      knownSizes[allParts[i]] = sz;
      estBytes += sz;
    }
    updateUI();

    // Start downloads; GET will refine the estimate again using true lengths.
    var dataUrlPromise = mergeFiles(dataParts);
    var wasmUrlPromise = mergeFiles(wasmParts);

    var results = await Promise.all([dataUrlPromise, wasmUrlPromise]);
    var dataUrl = results[0];
    var wasmUrl = results[1];

    phaseText.textContent = "initializing engine";

    var buildUrl = "Build";
    var loaderUrl = buildUrl + "/hk.loader.js";
    var config = {
      dataUrl: dataUrl,
      frameworkUrl: buildUrl + "/hk.framework.js",
      codeUrl: wasmUrl,
      streamingAssetsUrl: "StreamingAssets",
      companyName: "Team Cherry & Truffled",
      productName: "Hollow Knight",
      productVersion: "1.0"
    };

    var container = document.getElementById("unity-container");
    var canvas = document.getElementById("unity-canvas");
    var mobileWarning = document.getElementById("unity-mobile-warning");

    // Safer mobile detection: real mobile or small touch device
    var ua = navigator.userAgent || "";
    var isUA_Mobile = /Android|iPhone|iPad|iPod|IEMobile|Windows Phone/i.test(ua);
    var isSmallTouch = (navigator.maxTouchPoints || 0) > 0 && Math.max(screen.width, screen.height) < 900;
    var isLikelyMobile = isUA_Mobile || isSmallTouch;

    if (isLikelyMobile) {
      container.className = "unity-mobile";
      config.devicePixelRatio = 1;
      mobileWarning.style.display = "flex";
      setTimeout(function(){ mobileWarning.style.display="none"; }, 4000);
    } else {
      function resizeCanvas(){
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        canvas.style.width = window.innerWidth + "px";
        canvas.style.height = window.innerHeight + "px";
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
    }

    var s = document.createElement("script");
    s.src = loaderUrl;
    s.onload = function(){
      createUnityInstance(canvas, config, function(p){
        unityProgress = p || 0;
        phaseText.textContent = p<1 ? "engine load " + Math.round(p*100) + "%" : "starting";
        updateUI();
      }).then(function(instance){
        // Fade from loader UI to game
        document.getElementById("stage").style.display = "none";
        container.style.display = "block";
      }).catch(function(err){
        phaseText.textContent = "failed: " + err;
      });
    };
    s.onerror = function(){
      phaseText.textContent = "failed: loader missing";
    };
    document.head.appendChild(s);
  }
})();
</script>
</body>
</html>
