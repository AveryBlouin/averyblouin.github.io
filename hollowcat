<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google</title>
    <base href="https://cdn.jsdelivr.net/gh/web-ports/hollow-knight@latest/">

    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>

    <style>
        #unity-container{position:fixed; inset:0; display:none;}
        #unity-canvas{display:block; width:100%; height:100%; background:#000;}
    </style>
</head>
<body>
    <div id="info">
        <h1 id="title">averyblouin.github.io</h1>
        <h2 id="status">Waiting for scripts...</h2>
        <p id="dataprogress">Assets: 0/? mb (projected)</p>
        <p id="wasmprogress">Assembly: 0/? mb (projected)</p>
        <h1>Credit to Truffled.lol and Cat Nitro Games</h1>
    </div>

    <!-- Unity mount -->
    <div id="unity-container">
        <canvas id="unity-canvas"></canvas>
        <div id="unity-mobile-warning">
        WebGL builds are not supported on mobile devices.
        </div>
    </div>

    <script>
        // get rid of gn-math because they didn't make the game idk why the stuck it in the wasm???
        (() => {
            let oldAlert = alert;
            alert = function(msg) {
                if (msg.search("gn-math") != -1) {return;}
                return alert(msg);
            }
        })();

        const status = document.getElementById("status");
        const dataProgress = document.getElementById("dataprogress");
        const wasmProgress = document.getElementById("wasmprogress");

        /* ---------- Network progress model (updated) ---------- */
        // We keep a dynamic total estimate that can grow as we learn true sizes.
        //var estBytes = 0;           // current best estimate of total bytes
        //var loadedBytes = 0;        // bytes actually read so far
        var unityProgress = 0;      // 0..1 from Unity loader
        var knownSizes = Object.create(null);  // per-URL size we think we know (HEAD or GET)
        //var fallbackTotalMB = 860.36;          // only used if we have no sizes at all

        var dataInfo = {
            estBytes: 0,
            loadedBytes: 0,
            fallbackTotalMB: 828.76,
            complete: false,
        }
        var wasmInfo = {
            estBytes: 0,
            loadedBytes: 0,
            fallbackTotalMB: 31.6,
            complete: false,
        }

        function fmtMB(b){ return (b / (1024*1024)).toFixed(2); }

        async function getSize(url){
            try{
            var res = await fetch(url, { method:"HEAD" });
            var h = parseInt(res.headers.get("Content-Length")||"0", 10) || 0;
            return h;
            }catch(err){return 0;}
        }

        // Fetch a part while tracking progress; also learn/adjust true size from GET headers.
        async function fetchWithProgress(url, info){
            var response = await fetch(url);
            var getLen = parseInt(response.headers.get("Content-Length")||"0", 10) || 0;

            // If our HEAD guess was missing or wrong, adjust the estimate now.
            var prevKnown = knownSizes[url] || 0;
            if(getLen > 0){
            if(prevKnown === 0){
                info.estBytes += getLen;
                knownSizes[url] = getLen;
            }else if(getLen !== prevKnown){
                info.estBytes += (getLen - prevKnown);
                knownSizes[url] = getLen;
            }
            updateUI(); // reflect the better estimate immediately
            }

            var reader = response.body.getReader();
            var chunks = [];
            var received = 0;

            for(;;){
            var rr = await reader.read();
            if(rr.done) break;
            var value = rr.value;
            received += value.length;
            info.loadedBytes += value.length;

            // If for any reason we pass our estimate, bump the estimate up to match reality.
            if(info.loadedBytes > info.estBytes){
                info.estBytes = info.loadedBytes;
            }                     
            updateUI();

            chunks.push(value);
            }

            var fullBuffer = new Uint8Array(received);
            var offset = 0;
            for(var i=0;i<chunks.length;i++){ var chunk=chunks[i]; fullBuffer.set(chunk, offset); offset += chunk.length; }
            return fullBuffer.buffer;
        }

        async function mergeFiles(fileParts,info){
            var buffers = await Promise.all(fileParts.map(function(p){ return fetchWithProgress(p,info); }));
            var mergedBlob = new Blob(buffers);
            return URL.createObjectURL(mergedBlob);
        }

        function getParts(file, start, end){
            var parts = [];
            for(var i=start;i<=end;i++){ parts.push(file + ".part" + i); }
            return parts;
        }

        function updateUI() {
            var dataDynamicTotal = dataInfo.estBytes > 0 ? dataInfo.estBytes : (dataInfo.fallbackTotalMB * 1024 * 1024);
            var wasmDynamicTotal = wasmInfo.estBytes > 0 ? wasmInfo.estBytes : (wasmInfo.fallbackTotalMB * 1024 * 1024);
            
            if(wasmInfo.loadedBytes > wasmDynamicTotal){
                wasmDynamicTotal = wasmInfo.loadedBytes; // never let the "total" be smaller than "done"
            }
            if(dataInfo.loadedBytes > dataDynamicTotal){
                dataDynamicTotal = dataInfo.loadedBytes; // never let the "total" be smaller than "done"
            }

            /*
            var netPct = dynamicTotal > 0 ? (loadedBytes / dynamicTotal) : 0;
            var enginePct = (unityProgress||0) * 0.9; // reserve a slice for engine init
            var overall = Math.max(netPct, enginePct);

            // Clamp to [0,1] for display so we never show > 100%
            var clamped = Math.max(0, Math.min(1, overall));

            aptBar.textContent = asciiBar(clamped);
            aptPct.textContent = Math.round(clamped*100) + "%";
            mbText.textContent = fmtMB(loadedBytes) + " MB / " + fmtMB(dynamicTotal) + " MB";
            */

            dataProgress.innerText = `Assets: ${fmtMB(dataInfo.loadedBytes)}/${fmtMB(dataDynamicTotal)} mb (${dataInfo.Complete ? "complete" : "projected"})`;
            wasmProgress.innerText = `Assembly: ${fmtMB(wasmInfo.loadedBytes)}/${fmtMB(wasmDynamicTotal)} mb (${wasmInfo.Complete ? "complete" : "projected"})`;
        }

        /* ---------- Kick everything off after 3 seconds of "boot" ---------- */
        var started = false;
        setTimeout(function(){
            if(started) {return;};
            started = true;
            status.innerText = "Starting unity...";
            startUnityFlow();
        }, 3000);

        async function startUnityFlow() {
            var dataParts = getParts("Build/hk.data", 1, 42);
            var wasmParts = getParts("Build/hk.wasm", 1, 2);

            status.innerText = "Getting data size...";
            var estimatedDataSizes = await Promise.all(dataParts.map(getSize));
            var estimatedWasmSizes = await Promise.all(wasmParts.map(getSize));

            for(var i=0;i<dataParts.length;i++){
                var sz = estimatedDataSizes[i]||0;
                knownSizes[dataParts[i]] = sz;
                dataInfo.estBytes += sz;
            }
            for(var i=0;i<wasmParts.length;i++){
                var sz = estimatedWasmSizes[i]||0;
                knownSizes[wasmParts[i]] = sz;
                wasmInfo.estBytes += sz;
            }

            updateUI();

            // Start downloads; GET will refine the estimate again using true lengths.
            status.innerText = "Downloading assets...";
            var dataUrlPromise = mergeFiles(dataParts,dataInfo);
            var dataUrl = await dataUrlPromise;

            dataInfo.complete = true;
            updateUI();

            status.innerText = "Downloading assembly...";
            var wasmUrlPromise = mergeFiles(wasmParts,wasmInfo);
            var wasmUrl = await wasmUrlPromise;

            wasmInfo.complete = true;
            updateUI();

            status.innerText = "Initializing engine...";
            
            var buildUrl = "Build";
            var loaderUrl = buildUrl + "/hk.loader.js";
            var config = {
                dataUrl: dataUrl,
                frameworkUrl: buildUrl + "/hk.framework.js",
                codeUrl: wasmUrl,
                streamingAssetsUrl: "StreamingAssets",
                companyName: "Team Cherry & Truffled",
                productName: "Hollow Knight",
                productVersion: "1.0"
            };

            var container = document.getElementById("unity-container");
            var canvas = document.getElementById("unity-canvas");
            var mobileWarning = document.getElementById("unity-mobile-warning");

            // Safer mobile detection: real mobile or small touch device
            var ua = navigator.userAgent || "";
            var isUA_Mobile = /Android|iPhone|iPad|iPod|IEMobile|Windows Phone/i.test(ua);
            var isSmallTouch = (navigator.maxTouchPoints || 0) > 0 && Math.max(screen.width, screen.height) < 900;
            var isLikelyMobile = isUA_Mobile || isSmallTouch;

            if (isLikelyMobile) {
            container.className = "unity-mobile";
            config.devicePixelRatio = 1;
            mobileWarning.style.display = "flex";
            setTimeout(function(){ mobileWarning.style.display="none"; }, 4000);
            } else {
            function resizeCanvas(){
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                canvas.style.width = window.innerWidth + "px";
                canvas.style.height = window.innerHeight + "px";
            }
            resizeCanvas();
            window.addEventListener("resize", resizeCanvas);
            }

            var s = document.createElement("script");
            s.src = loaderUrl;
            s.onload = function(){
            createUnityInstance(canvas, config, function(p){
                unityProgress = p || 0;
                status.textContent = p<1 ? "engine load " + Math.round(p*100) + "%" : "starting";
                updateUI();
            }).then(function(instance){
                // Fade from loader UI to game
                document.getElementById("info").style.display = "none";
                container.style.display = "block";
            }).catch(function(err){
                status.textContent = "failed: " + err;
            });
            };
            s.onerror = function(){
            phaseText.textContent = "failed: loader missing";
            };
            document.head.appendChild(s);
        }

        status.innerText = "Waiting to initialize (3s)";
    </script>
</body>
</html>
